{"version":3,"file":"functions.js","mappings":"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","sources":["webpack://excel-custom-functions/webpack/bootstrap","webpack://excel-custom-functions/./src/functions/functions.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n * See LICENSE in the project root for license information.\n */\n\n/* global clearInterval, console, CustomFunctions, setInterval, XMLHttpRequest */\n\n/**\n * SqExcel Custom Functions\n * \n * This add-in provides 2 Excel functions for working with Seeq data:\n * - SEARCH_SENSORS: Search for sensors in your Seeq environment\n * - PULL_SENSOR_DATA: Pull time series data from Seeq sensors\n * \n * SETUP INSTRUCTIONS:\n * 1. Create a Seeq Access Key:\n *    - Go to your Seeq environment\n *    - Click on your username in the top right\n *    - Select \"Create Access Key\"\n *    - Copy both the Key (ID) and Password - you'll need both!\n * \n * 2. Authenticate in Excel:\n *    - Open the SqExcel taskpane (if not visible, go to Insert > My Add-ins)\n *    - Enter your Seeq server URL (e.g., https://your-server.seeq.tech)\n *    - Enter the Access Key and Password from step 1\n *    - Click \"Authenticate\"\n *    - Once authenticated, you can use the Excel functions below\n * \n * 3. Using the Functions:\n *    - SEARCH_SENSORS: =SEARCH_SENSORS(A1:C1) where A1:C1 contains sensor names\n *    - PULL_SENSOR_DATA: =PULL_SENSOR_DATA(A1:C1,\"2024-01-01T00:00:00\",\"2024-01-31T23:59:59\",\"15min\")\n * \n * TROUBLESHOOTING:\n * - If you see \"#NAME?\" errors, make sure the add-in is properly loaded\n * - If authentication fails, check your Seeq server URL and credentials\n * - If data doesn't load, verify your sensor names exist in Seeq\n * - For detailed diagnostics, run a connection test in the taskpane\n */\n\n\n// Backend server configuration\nconst BACKEND_URL = 'https://sqexcel.up.railway.app';\n\n/**\n * Helper function to get stored Seeq credentials from localStorage\n */\nfunction getStoredCredentials(): any {\n  try {\n    // Get credentials from localStorage (same storage used by taskpane)\n    const saved = localStorage.getItem(\"seeq_credentials\");\n    if (saved) {\n      const credentials = JSON.parse(saved);\n      \n      // Check if credentials are still valid (not expired)\n      const savedTime = new Date(credentials.timestamp);\n      const now = new Date();\n      const hoursDiff = (now.getTime() - savedTime.getTime()) / (1000 * 60 * 60);\n      \n      if (hoursDiff < 24) { // Credentials valid for 24 hours\n        return credentials;\n      } else {\n        // Credentials expired, remove them\n        localStorage.removeItem(\"seeq_credentials\");\n      }\n    }\n    return null;\n  } catch (error) {\n    console.log(\"Could not get stored credentials from localStorage:\", error);\n    return null;\n  }\n}\n\n/**\n * Helper function to make synchronous HTTP requests to the backend server\n * Note: This uses XMLHttpRequest synchronously, which is deprecated but works in Excel custom functions\n */\nfunction callBackendSync(endpoint: string, data: any = null): any {\n  try {\n    const xhr = new XMLHttpRequest();\n    const url = `${BACKEND_URL}${endpoint}`;\n    \n    console.log(`[DEBUG] Attempting to connect to: ${url}`);\n    console.log(`[DEBUG] Endpoint: ${endpoint}`);\n    console.log(`[DEBUG] Data:`, data);\n    \n    // Use synchronous request (deprecated but works in Excel custom functions)\n    xhr.open(data ? 'POST' : 'GET', url, false);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    \n    console.log(`[DEBUG] Request opened, sending...`);\n    \n    if (data) {\n      xhr.send(JSON.stringify(data));\n    } else {\n      xhr.send();\n    }\n    \n    console.log(`[DEBUG] Response received - Status: ${xhr.status}, StatusText: ${xhr.statusText}`);\n    console.log(`[DEBUG] Response headers:`, xhr.getAllResponseHeaders());\n    console.log(`[DEBUG] Response text:`, xhr.responseText.substring(0, 200) + '...');\n    \n    if (xhr.status === 200) {\n      try {\n        const parsed = JSON.parse(xhr.responseText);\n        console.log(`[DEBUG] Successfully parsed response:`, parsed);\n        return parsed;\n      } catch (e) {\n        console.log(`[DEBUG] Failed to parse response:`, e);\n        return {\n          success: false,\n          error: `Failed to parse response: ${(e as Error).message}`,\n          rawResponse: xhr.responseText\n        };\n      }\n    } else {\n      console.log(`[DEBUG] HTTP error: ${xhr.status} - ${xhr.statusText}`);\n      return {\n        success: false,\n        error: `HTTP ${xhr.status}: ${xhr.statusText}`,\n        responseText: xhr.responseText,\n        url: url\n      };\n    }\n  } catch (error) {\n    console.log(`[DEBUG] Exception during request:`, error);\n    return {\n      success: false,\n      error: `Backend request failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n      details: error instanceof Error ? error.stack : 'No stack trace',\n      url: `${BACKEND_URL}${endpoint}`\n    };\n  }\n}\n\n\n/**\n * Helper function to convert timestamps to Excel serial numbers\n * Returns Excel's internal date representation for better compatibility\n * Excel serial number = (JS timestamp / (1000 * 60 * 60 * 24)) + 25569\n * \n * Note: These serial numbers will display as large numbers (e.g., 45870.0)\n * To see them as readable dates, users should:\n * 1. Select the timestamp column\n * 2. Right-click → Format Cells → Date\n * 3. Choose desired date format (e.g., \"3/14/12 1:30 PM\")\n */\nfunction convertToExcelSerialNumber(timestamp: any): number {\n  try {\n    // Handle different timestamp formats that might come from the backend\n    let date: Date;\n    \n    if (typeof timestamp === 'string') {\n      // Try to parse ISO string or other date formats\n      date = new Date(timestamp);\n    } else if (timestamp instanceof Date) {\n      date = timestamp;\n    } else if (typeof timestamp === 'number') {\n      // Handle Unix timestamp\n      date = new Date(timestamp);\n    } else {\n      // Fallback for unknown formats\n      return 0; // Return 0 for invalid dates\n    }\n    \n    // Check if date is valid\n    if (isNaN(date.getTime())) {\n      return 0; // Return 0 for invalid dates\n    }\n    \n    // Convert to Excel serial number\n    // Excel serial number = (JS timestamp / (1000 * 60 * 60 * 24)) + 25569\n    // Where 25569 is the number of days between 1900-01-01 and 1970-01-01\n    const excelSerial = (date.getTime() / (1000 * 60 * 60 * 24)) + 25569;\n    \n    return excelSerial;\n  } catch (error) {\n    // If any error occurs during conversion, return 0\n    return 0;\n  }\n}\n\n/**\n * Pulls time series data from Seeq sensors over a specified time range.\n * This is an array function that should be called on a range that can accommodate the output.\n * \n * @customfunction PULL_SENSOR_DATA\n * @param sensorNames Range containing sensor names (e.g., B1:D1)\n * @param startDatetime Start time for data pull (ISO format: \"2024-01-01T00:00:00\")\n * @param endDatetime End time for data pull (ISO format: \"2024-01-31T23:59:59\")\n * @param grid Grid interval for data (e.g., \"15min\", \"1h\", \"1d\") - defaults to \"15min\"\n * @returns Array containing timestamp column (as Excel serial numbers) and sensor data columns\n */\nexport function PULL_SENSOR_DATA(\n  sensorNames: string[][],\n  startDatetime: string,\n  endDatetime: string,\n  grid: string = \"15min\"\n): string[][] {\n  try {\n    // Flatten the sensor names array and filter out empty cells\n    const sensorNamesList = sensorNames\n      .flat()\n      .filter(name => name && name.trim() !== \"\");\n    \n    if (sensorNamesList.length === 0) {\n      return [[\"Error: No sensor names provided\"]];\n    }\n    \n    // Validate datetime format\n    const startDate = new Date(startDatetime);\n    const endDate = new Date(endDatetime);\n    \n    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {\n      return [[\"Error: Invalid datetime format. Use ISO format: YYYY-MM-DDTHH:MM:SS\"]];\n    }\n    \n    if (startDate >= endDate) {\n      return [[\"Error: Start datetime must be before end datetime\"]];\n    }\n    \n    // Validate grid format\n    const gridPattern = /^(\\d+)(min|h|d|s)$/;\n    if (!gridPattern.test(grid)) {\n      return [[\"Error: Invalid grid format. Use format like '15min', '1h', '1d', '30s'\"]];\n    }\n\n        // Check if we have stored credentials\n    const authCredentials = getStoredCredentials();\n    if (!authCredentials) {\n      return [[\"Error: Not authenticated to Seeq. Please use the SqExcel taskpane to authenticate first.\"]];\n    }\n    \n    // Call backend server with credentials\n    const result = callBackendSync('/api/seeq/sensor-data', {\n      sensorNames: sensorNamesList,\n      startDatetime,\n      endDatetime,\n      grid,\n      url: authCredentials.url,\n      accessKey: authCredentials.accessKey,\n      password: authCredentials.password,\n      authProvider: \"Seeq\",\n      ignoreSslErrors: false\n    });\n    \n    if (result.success && result.data && result.data.length > 0) {\n      // Create header row with timestamp and sensor names\n      const headers = [\"Timestamp\"].concat(result.data_columns || []);\n      \n      // Create data rows with formatted timestamps\n      const dataRows = result.data.map((row: any) => {\n        const timestamp = row.Timestamp || row.index || \"N/A\";\n        // Convert timestamp to Excel serial number for best compatibility\n        const excelSerialTimestamp = convertToExcelSerialNumber(timestamp);\n        const values = (result.data_columns || []).map((col: string) => {\n          return row[col] !== undefined ? row[col] : \"N/A\";\n        });\n        return [excelSerialTimestamp].concat(values);\n      });\n      \n      return [headers].concat(dataRows);\n    } else {\n      // Check if backend server is not running\n      if (result.error && result.error.includes('Failed to fetch') || result.error.includes('NetworkError')) {\n        return [\n          [\"Backend server not running\"],\n          [\"Please start the backend server:\"],\n          [\"1. Open terminal in the backend folder\"],\n          [\"2. Run: npm install && npm start\"],\n          [\"3. Then use this function again\"]\n        ];\n      }\n      \n      return [\n        [\"No data returned\"],\n        [\"Error: \" + (result.error || result.message || \"Unknown error\")],\n        [\"Sensors: \" + sensorNamesList.join(\", \")],\n        [\"Time Range: \" + startDatetime + \" to \" + endDatetime]\n      ];\n    }\n    \n  } catch (error) {\n    return [[\"Error: \" + (error instanceof Error ? error.message : 'Unknown error')]];\n  }\n}\n\n/**\n * Searches for sensors in Seeq without pulling data.\n * \n * @customfunction SEARCH_SENSORS\n * @param sensorNames Range containing sensor names (e.g., B1:D1)\n * @returns Array containing search results for each sensor\n */\nexport function SEARCH_SENSORS(sensorNames: string[][]): string[][] {\n  try {\n    // Flatten the sensor names array and filter out empty cells\n    const sensorNamesList = sensorNames\n      .flat()\n      .filter(name => name && name.trim() !== \"\");\n    \n    if (sensorNamesList.length === 0) {\n      return [[\"Error: No sensor names provided\"]];\n    }\n\n    // Check if we have stored credentials\n    const searchCredentials = getStoredCredentials();\n    if (!searchCredentials) {\n      return [[\"Error: Not authenticated to Seeq. Please use the SqExcel taskpane to authenticate first.\"]];\n    }\n    \n    // Call backend server with credentials\n    const result = callBackendSync('/api/seeq/search-sensors', {\n      sensorNames: sensorNamesList,\n      url: searchCredentials.url,\n      accessKey: searchCredentials.accessKey,\n      password: searchCredentials.password,\n      authProvider: \"Seeq\",\n      ignoreSslErrors: false\n    });\n    \n    if (result.success && result.search_results && result.search_results.length > 0) {\n      // Create header row\n      const headers = [\"Name\", \"ID\", \"Datasource Name\", \"Value Unit Of Measure\", \"Description\"];\n      \n      // Create data rows\n      const dataRows = result.search_results.map((sensor: any) => {\n        return [\n          sensor[\"Name\"] || \"N/A\",\n          sensor[\"ID\"] || \"Not Found\",\n          sensor[\"Datasource Name\"] || \"N/A\",\n          sensor[\"Value Unit Of Measure\"] || \"N/A\",\n          sensor[\"Description\"] || \"N/A\"\n        ];\n      });\n      \n      return [headers].concat(dataRows);\n    } else {\n      // Check if backend server is not running\n      if (result.error && result.error.includes('Failed to fetch') || result.error.includes('NetworkError')) {\n        return [\n          [\"Backend server not running\"]\n        ];\n      }\n      \n      return [\n        [\"No search results returned\"],\n        [\"Error: \" + (result.error || result.message || \"Unknown error\")],\n        [\"Sensors: \" + sensorNamesList.join(\", \")]\n      ];\n    }\n    \n  } catch (error) {\n    return [[\"Error: \" + (error instanceof Error ? error.message : 'Unknown error')]];\n  }\n}\n\nCustomFunctions.associate(\"PULL_SENSOR_DATA\", PULL_SENSOR_DATA);\nCustomFunctions.associate(\"SEARCH_SENSORS\", SEARCH_SENSORS);"],"names":["BACKEND_URL","getStoredCredentials","saved","localStorage","getItem","credentials","JSON","parse","savedTime","Date","timestamp","getTime","removeItem","error","console","log","callBackendSync","endpoint","data","arguments","length","undefined","xhr","XMLHttpRequest","url","concat","open","setRequestHeader","send","stringify","status","statusText","getAllResponseHeaders","responseText","substring","success","parsed","e","message","rawResponse","Error","details","stack","CustomFunctions","associate","sensorNames","startDatetime","endDatetime","grid","sensorNamesList","flat","filter","name","trim","startDate","endDate","isNaN","test","authCredentials","result","accessKey","password","authProvider","ignoreSslErrors","headers","data_columns","dataRows","map","row","excelSerialTimestamp","date","convertToExcelSerialNumber","Timestamp","index","values","col","includes","join","searchCredentials","search_results","sensor"],"sourceRoot":""}