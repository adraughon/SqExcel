{"version":3,"file":"functions.js","mappings":"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","sources":["webpack://excel-custom-functions/webpack/bootstrap","webpack://excel-custom-functions/webpack/runtime/define property getters","webpack://excel-custom-functions/webpack/runtime/hasOwnProperty shorthand","webpack://excel-custom-functions/./src/functions/functions.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","/*\n * Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n * See LICENSE in the project root for license information.\n */\n\n/* global clearInterval, console, CustomFunctions, setInterval, XMLHttpRequest */\n\n/**\n * SqExcel Custom Functions\n * \n * This add-in provides Excel functions for working with Seeq data:\n * - SEARCH_SENSORS: Search for sensors in your Seeq environment\n * - PULL: Pull time series data from Seeq sensors\n * - CREATE_PLOT_CODE: Generate Python plotting code with embedded sensor data\n * \n * SETUP INSTRUCTIONS:\n * 1. Create a Seeq Access Key:\n *    - Go to your Seeq environment\n *    - Click on your username in the top right\n *    - Select \"Create Access Key\"\n *    - Copy both the Key (ID) and Password - you'll need both!\n * \n * 2. Authenticate in Excel:\n *    - Open the SqExcel taskpane (if not visible, go to Insert > My Add-ins)\n *    - Enter your Seeq server URL (e.g., https://your-server.seeq.tech)\n *    - Enter the Access Key and Password from step 1\n *    - Click \"Authenticate\"\n *    - Once authenticated, you can use the Excel functions below\n * \n * 3. Using the Functions:\n *    - SEARCH_SENSORS: =SEARCH_SENSORS(A1:C1) where A1:C1 contains sensor names\n *    - PULL: =PULL(A1:C1,\"2024-01-01T00:00:00\",\"2024-01-31T23:59:59) - defaults to 1000 points\n *    - PULL with grid: =PULL(A1:C1,\"2024-01-01T00:00:00\",\"2024-01-31T23:59:59\",\"grid\",\"15min\")\n *    - PULL with points: =PULL(A1:C1,\"2024-01-01T00:00:00\",\"2024-01-31T23:59:59,\"points\",500)\n *    - CREATE_PLOT_CODE: =CREATE_PLOT_CODE(A1,\"2024-01-01T00:00:00\",\"2024-01-31T23:59:59\") - basic usage\n *    - CREATE_PLOT_CODE with options: =CREATE_PLOT_CODE(A1,\"2024-01-01\",\"2024-01-02\",100,0.5,4,TRUE,TRUE,0.8,\"green\",\"normal\",\"Temperature\")\n * \n * TROUBLESHOOTING:\n * - If you see \"#NAME?\" errors, make sure the add-in is properly loaded\n * - If authentication fails, check your Seeq server URL and credentials\n * - If data doesn't load, verify your sensor names exist in Seeq\n * - For detailed diagnostics, run a connection test in the taskpane\n */\n\n\n// Backend server configuration\nconst BACKEND_URL = 'https://sqexcel.up.railway.app';\n\n/**\n * Helper function to get stored Seeq credentials from localStorage\n */\nfunction getStoredCredentials(): any {\n  try {\n    // Get credentials from localStorage (same storage used by taskpane)\n    const saved = localStorage.getItem(\"seeq_credentials\");\n    if (saved) {\n      const credentials = JSON.parse(saved);\n      \n      // Check if credentials are still valid (not expired)\n      const savedTime = new Date(credentials.timestamp);\n      const now = new Date();\n      const hoursDiff = (now.getTime() - savedTime.getTime()) / (1000 * 60 * 60);\n      \n      if (hoursDiff < 24) { // Credentials valid for 24 hours\n        return credentials;\n      } else {\n        // Credentials expired, remove them\n        localStorage.removeItem(\"seeq_credentials\");\n      }\n    }\n    return null;\n  } catch (error) {\n    return null;\n  }\n}\n\n/**\n * Helper function to make synchronous HTTP requests to the backend server\n * Note: This uses XMLHttpRequest synchronously, which is deprecated but works in Excel custom functions\n */\nfunction callBackendSync(endpoint: string, data: any = null): any {\n  try {\n    const xhr = new XMLHttpRequest();\n    const url = `${BACKEND_URL}${endpoint}`;\n    \n    \n    // Use synchronous request (deprecated but works in Excel custom functions)\n    xhr.open(data ? 'POST' : 'GET', url, false);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    \n    \n    if (data) {\n      xhr.send(JSON.stringify(data));\n    } else {\n      xhr.send();\n    }\n    \n    \n    if (xhr.status === 200) {\n      try {\n        const parsed = JSON.parse(xhr.responseText);\n        return parsed;\n      } catch (e) {\n        return {\n          success: false,\n          error: `Failed to parse response: ${(e as Error).message}`,\n          rawResponse: xhr.responseText\n        };\n      }\n    } else {\n      return {\n        success: false,\n        error: `HTTP ${xhr.status}: ${xhr.statusText}`,\n        responseText: xhr.responseText,\n        url: url\n      };\n    }\n  } catch (error) {\n    return {\n      success: false,\n      error: `Backend request failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n      details: error instanceof Error ? error.stack : 'No stack trace',\n      url: `${BACKEND_URL}${endpoint}`\n    };\n  }\n}\n\n\n/**\n * Helper function to convert timestamps to Excel serial numbers\n * Returns Excel's internal date representation for better compatibility\n * Excel serial number = (JS timestamp / (1000 * 60 * 60 * 24)) + 25569\n * \n * Note: These serial numbers will display as large numbers (e.g., 45870.0)\n * To see them as readable dates, users should:\n * 1. Select the timestamp column\n * 2. Right-click → Format Cells → Date\n * 3. Choose desired date format (e.g., \"3/14/12 1:30 PM\")\n * \n * This function preserves the original timezone information from the backend\n * to ensure timestamps display correctly in the user's local timezone.\n */\nfunction convertToExcelSerialNumber(timestamp: any): number {\n  try {\n    // Normalize the input into a Date representing the intended moment-in-time\n    let date: Date | null = null;\n\n    // If it's already an Excel serial (number or numeric string), just return it directly\n    if (typeof timestamp === 'number' && timestamp > 0 && timestamp < 100000) {\n      return timestamp;\n    }\n    if (typeof timestamp === 'string' && /^\\d+(?:\\.\\d+)?$/.test(timestamp.trim())) {\n      const asNum = parseFloat(timestamp.trim());\n      if (!isNaN(asNum) && asNum > 0 && asNum < 100000) {\n        return asNum;\n      }\n    }\n\n    if (timestamp instanceof Date) {\n      date = new Date(timestamp.getTime());\n    } else if (typeof timestamp === 'number') {\n      // Heuristics:\n      // - Excel serials are usually < 100000\n      // - Unix ms timestamps are > 10^11, Unix seconds are between 10^9 and 10^10\n      if (timestamp > 1e11) {\n        // treat as Unix milliseconds\n        date = new Date(timestamp);\n      } else if (timestamp > 1e9 && timestamp < 1e11) {\n        // treat as Unix seconds\n        date = new Date(timestamp * 1000);\n      } else if (timestamp > 0 && timestamp < 100000) {\n        // If a caller sent a number that is clearly an Excel serial, return it directly\n        return timestamp;\n      } else {\n        // Fallback: treat as ms\n        date = new Date(timestamp);\n      }\n    } else if (typeof timestamp === 'string') {\n      // Handle ISO-like strings directly (native will keep instant with timezone if present)\n      // Also handle \"YYYY-MM-DD HH:MM:SS\" as local time\n      const localMatch = timestamp.match(/^(\\d{4})-(\\d{2})-(\\d{2})\\s+(\\d{2}):(\\d{2}):(\\d{2})$/);\n      if (localMatch) {\n        const [, y, m, d, hh, mm, ss] = localMatch;\n        date = new Date(parseInt(y), parseInt(m) - 1, parseInt(d), parseInt(hh), parseInt(mm), parseInt(ss), 0);\n      } else {\n        // Try custom parser for M/D/YYYY style and AM/PM variants\n        const parsed = parseDate(timestamp);\n        if (parsed && !isNaN(parsed.getTime())) {\n          date = parsed;\n        } else {\n          // Native parse (will interpret without timezone as local)\n          const nd = new Date(timestamp);\n          date = isNaN(nd.getTime()) ? null : nd;\n        }\n      }\n    }\n\n    if (!date || isNaN(date.getTime())) {\n      return 0;\n    }\n\n    // Convert to Excel serial number using UTC components plus local offset once.\n    // This preserves exact wall-clock minutes/seconds and avoids double-offsetting across DST.\n    const tzOffsetMin = date.getTimezoneOffset();\n    const utcMs = date.getTime();\n    const localWallClockMs = utcMs - tzOffsetMin * 60000;\n    const serial = localWallClockMs / 86400000 + 25569;\n\n    return serial;\n  } catch (_err) {\n    return 0;\n  }\n}\n\n/**\n * Custom date parsing function to handle various date formats consistently\n * @param dateString - Date string in various formats\n * @returns Date object or null if parsing fails\n */\nfunction parseDate(dateString: string): Date | null {\n  if (!dateString || typeof dateString !== 'string') {\n    return null;\n  }\n\n  // Excel serial numbers (plain numeric strings under 100000)\n  const trimmed = dateString.trim();\n  if (/^\\d+(?:\\.\\d+)?$/.test(trimmed)) {\n    const serialNumber = parseFloat(trimmed);\n    if (!isNaN(serialNumber) && serialNumber > 0 && serialNumber < 100000) {\n      // Convert Excel serial to a JS Date that renders as LOCAL midnight.\n      // 1) Compute UTC midnight for the serial\n      const daysSinceUnixEpoch = serialNumber - 25569;\n      const msUtc = Math.round(daysSinceUnixEpoch * 86400000);\n      // 2) Apply the timezone offset at that point in time so that toString() shows local midnight\n      const tzAtDateMin = new Date(msUtc).getTimezoneOffset();\n      const msLocal = msUtc + tzAtDateMin * 60000;\n      return new Date(msLocal);\n    }\n  }\n\n  // ISO format -> rely on native\n  if (dateString.includes('T')) {\n    const d = new Date(dateString);\n    return isNaN(d.getTime()) ? null : d;\n  }\n\n  // Handle YYYY-MM-DD HH:MM:SS as local time\n  const ymdLocal = trimmed.match(/^(\\d{4})-(\\d{2})-(\\d{2})\\s+(\\d{2}):(\\d{2}):(\\d{2})$/);\n  if (ymdLocal) {\n    const [, y, m, d, hh, mm, ss] = ymdLocal;\n    return new Date(parseInt(y, 10), parseInt(m, 10) - 1, parseInt(d, 10), parseInt(hh, 10), parseInt(mm, 10), parseInt(ss, 10));\n  }\n\n  // Fallback\n  const date = new Date(dateString);\n  return isNaN(date.getTime()) ? null : date;\n}\n\n/**\n * Pulls time series data from Seeq sensors over a specified time range.\n * This is an array function that should be called on a range that can accommodate the output.\n * \n * @customfunction PULL\n * @param sensorNames Range containing sensor names (e.g., B1:D1)\n * @param startDatetime Start time for data pull (ISO format: \"2024-01-01T00:00:00\" or \"8/1/2025 0:00\")\n * @param endDatetime End time for data pull (ISO format: \"2024-01-31T23:59:59\" or \"8/3/2025 0:00\")\n * @param mode Data retrieval mode: \"grid\" for time-based intervals or \"points\" for number of points - defaults to \"points\"\n * @param modeValue Grid interval (e.g., \"15min\", \"1h\", \"1d\") when mode=\"grid\" OR number of points when mode=\"points\" - defaults to 1000\n * @returns Array containing timestamp column (as Excel serial numbers) and sensor data columns\n * \n * TIMEZONE BEHAVIOR:\n * - Input dates without timezone info are treated as local timezone\n * - Returned data timestamps are in the same timezone as the input (local timezone)\n * - This matches user expectations for natural date/time input\n */\nexport function PULL(\n  sensorNames: string[][],\n  startDatetime: string,\n  endDatetime: string,\n  mode?: string,\n  modeValue?: string | number\n): string[][] {\n  try {\n    // Flatten the sensor names array and filter out empty cells\n    const sensorNamesList = sensorNames\n      .flat()\n      .filter(name => name && name.trim() !== \"\");\n    \n    if (sensorNamesList.length === 0) {\n      return [[\"Error: No sensor names provided\"]];\n    }\n    \n    // Validate datetime format and ensure consistent timezone handling\n    let startDate: Date;\n    let endDate: Date;\n    \n  // Parse dates using custom parser\n  startDate = parseDate(startDatetime);\n  endDate = parseDate(endDatetime);\n  \n  if (!startDate || !endDate) {\n    return [[\"Error: Invalid datetime format. Use formats like: 8/1/2025 0:00 or 2024-01-01T00:00:00\"]];\n  }\n  \n  // Calculate time range in seconds (needed for both modes)\n  const timeRangeMs = endDate.getTime() - startDate.getTime();\n  const timeRangeSeconds = Math.floor(timeRangeMs / 1000);\n    \n    if (startDate >= endDate) {\n      return [[\"Error: Start datetime must be before end datetime\"]];\n    }\n    \n    // Set default values for optional parameters\n    const actualMode = mode || \"points\";\n    const actualModeValue = modeValue || (actualMode === \"points\" ? 1000 : \"15min\");\n    \n    // Validate mode parameter\n    if (actualMode !== \"grid\" && actualMode !== \"points\") {\n      return [[\"Error: Mode must be 'grid' or 'points'\"]];\n    }\n    \n    \n    // Calculate grid based on mode\n    let grid: string;\n    if (actualMode === \"grid\") {\n      // Use actualModeValue as grid directly\n      grid = String(actualModeValue);\n      // Validate grid format\n      const gridPattern = /^(\\d+)(min|h|d|s)$/;\n      if (!gridPattern.test(grid)) {\n        return [[\"Error: Invalid grid format. Use format like '15min', '1h', '1d', '30s'\"]];\n      }\n    } else {\n      // actualMode === \"points\" - calculate grid from number of points\n      const numPoints = typeof actualModeValue === 'number' ? actualModeValue : parseInt(String(actualModeValue));\n      if (isNaN(numPoints) || numPoints <= 0) {\n        return [[\"Error: Number of points must be a positive integer\"]];\n      }\n      \n      // Calculate seconds per point (must be integer)\n      const secondsPerPoint = Math.floor(timeRangeSeconds / numPoints);\n      \n      if (secondsPerPoint < 1) {\n        return [\n          [\"Error: Time range too short for requested number of points. Try fewer points or a longer time range.\"]\n        ];\n      }\n      \n      // Convert to grid format\n      grid = `${secondsPerPoint}s`;\n    }\n\n        // Check if we have stored credentials\n    const authCredentials = getStoredCredentials();\n    if (!authCredentials) {\n      return [[\"Error: Not authenticated to Seeq. Please use the SqExcel taskpane to authenticate first.\"]];\n    }\n    \n    // Get user's timezone\n    const userTimezone = (function() {\n      try {\n        const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;\n        return tz || 'UTC';\n      } catch (_e) {\n        return 'UTC';\n      }\n    })();\n    \n    // Call backend server with credentials\n    const result = callBackendSync('/api/seeq/sensor-data', {\n      sensorNames: sensorNamesList,\n      startDatetime,\n      endDatetime,\n      grid,\n      userTimezone,\n      url: authCredentials.url,\n      accessKey: authCredentials.accessKey,\n      password: authCredentials.password,\n      authProvider: \"Seeq\",\n      ignoreSslErrors: false\n    });\n    \n    if (result.success && result.data && result.data.length > 0) {\n      // Create header row with timestamp and sensor names\n      const headers = [\"Timestamp\"].concat(result.data_columns || []);\n      \n      // Create data rows with formatted timestamps\n      const dataRows = result.data.map((row: any) => {\n        const timestamp = row.Timestamp || row.index || \"N/A\";\n        // Convert timestamp to Excel serial number for best compatibility\n        const excelSerialTimestamp = convertToExcelSerialNumber(timestamp);\n        const values = (result.data_columns || []).map((col: string) => {\n          return row[col] !== undefined ? row[col] : \"N/A\";\n        });\n        return [excelSerialTimestamp].concat(values);\n      });\n      \n      \n      return [headers].concat(dataRows);\n    } else {\n      // Check if backend server is not running\n      if (result.error && result.error.includes('Failed to fetch') || result.error.includes('NetworkError')) {\n        return [\n          [\"Backend server not running\"],\n          [\"Please start the backend server:\"],\n          [\"1. Open terminal in the backend folder\"],\n          [\"2. Run: npm install && npm start\"],\n          [\"3. Then use this function again\"]\n        ];\n      }\n      \n      return [\n        [\"No data returned\"],\n        [\"Error: \" + (result.error || result.message || \"Unknown error\")],\n        [\"Sensors: \" + sensorNamesList.join(\", \")],\n        [\"Time Range: \" + startDatetime + \" to \" + endDatetime]\n      ];\n    }\n    \n  } catch (error) {\n    return [[\"Error: \" + (error instanceof Error ? error.message : 'Unknown error')]];\n  }\n}\n\n/**\n * Searches for sensors in Seeq without pulling data.\n * \n * @customfunction SEARCH_SENSORS\n * @param sensorNames Range containing sensor names (e.g., B1:D1)\n * @returns Array containing search results for each sensor\n */\nexport function SEARCH_SENSORS(sensorNames: string[][]): string[][] {\n  try {\n    // Flatten the sensor names array and filter out empty cells\n    const sensorNamesList = sensorNames\n      .flat()\n      .filter(name => name && name.trim() !== \"\");\n    \n    if (sensorNamesList.length === 0) {\n      return [[\"Error: No sensor names provided\"]];\n    }\n\n    // Check if we have stored credentials\n    const searchCredentials = getStoredCredentials();\n    if (!searchCredentials) {\n      return [[\"Error: Not authenticated to Seeq. Please use the SqExcel taskpane to authenticate first.\"]];\n    }\n    \n    // Call backend server with credentials\n    const result = callBackendSync('/api/seeq/search-sensors', {\n      sensorNames: sensorNamesList,\n      url: searchCredentials.url,\n      accessKey: searchCredentials.accessKey,\n      password: searchCredentials.password,\n      authProvider: \"Seeq\",\n      ignoreSslErrors: false\n    });\n    \n    if (result.success && result.search_results && result.search_results.length > 0) {\n      // Create header row\n      const headers = [\"Name\", \"ID\", \"Datasource Name\", \"Value Unit Of Measure\", \"Description\"];\n      \n      // Create data rows\n      const dataRows = result.search_results.map((sensor: any) => {\n        return [\n          sensor[\"Name\"] || \"N/A\",\n          sensor[\"ID\"] || \"Not Found\",\n          sensor[\"Datasource Name\"] || \"N/A\",\n          sensor[\"Value Unit Of Measure\"] || \"N/A\",\n          sensor[\"Description\"] || \"N/A\"\n        ];\n      });\n      \n      return [headers].concat(dataRows);\n    } else {\n      // Check if backend server is not running\n      if (result.error && result.error.includes('Failed to fetch') || result.error.includes('NetworkError')) {\n        return [\n          [\"Backend server not running\"]\n        ];\n      }\n      \n      return [\n        [\"No search results returned\"],\n        [\"Error: \" + (result.error || result.message || \"Unknown error\")],\n        [\"Sensors: \" + sensorNamesList.join(\", \")]\n      ];\n    }\n    \n  } catch (error) {\n    return [[\"Error: \" + (error instanceof Error ? error.message : 'Unknown error')]];\n  }\n}\n\n/**\n * Gets the current value of a sensor at the present time.\n * Returns a single-cell scalar value.\n * \n * @customfunction CURRENT\n * @param sensorName Name of the sensor (e.g., \"Area/Tag\")\n * @returns Current value as a scalar, or an error string\n */\nexport function CURRENT(sensorName: string): any {\n  try {\n    if (!sensorName || typeof sensorName !== 'string' || sensorName.trim() === '') {\n      return \"Error: Sensor name is required\";\n    }\n\n    const authCredentials = getStoredCredentials();\n    if (!authCredentials) {\n      return \"Error: Not authenticated to Seeq. Please use the SqExcel taskpane to authenticate first.\";\n    }\n\n    // Determine a short time window ending now, using user's timezone context\n    const now = new Date();\n    const endDatetime = now.toISOString();\n    const startDatetime = new Date(now.getTime() - 60 * 1000).toISOString(); // last 60 seconds\n\n    // Request at 1-second grid and take the latest value\n    const userTimezone = (function() {\n      try {\n        const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;\n        return tz || 'UTC';\n      } catch (_e) {\n        return 'UTC';\n      }\n    })();\n\n    const result = callBackendSync('/api/seeq/sensor-data', {\n      sensorNames: [sensorName.trim()],\n      startDatetime,\n      endDatetime,\n      grid: '1s',\n      userTimezone,\n      url: authCredentials.url,\n      accessKey: authCredentials.accessKey,\n      password: authCredentials.password,\n      authProvider: \"Seeq\",\n      ignoreSslErrors: false\n    });\n\n    if (result.success && Array.isArray(result.data) && result.data.length > 0) {\n      const columns: string[] = result.data_columns || [];\n      if (!columns || columns.length === 0) {\n        return \"Error: No data columns returned\";\n      }\n      const valueColumn = columns[0];\n      // Take the last row's value\n      const lastRow = result.data[result.data.length - 1] || {};\n      const value = lastRow[valueColumn];\n      return (value !== undefined && value !== null) ? value : \"Error: No current value available\";\n    }\n\n    return \"Error: \" + (result.error || result.message || \"No data returned\");\n  } catch (error) {\n    return \"Error: \" + (error instanceof Error ? error.message : 'Unknown error');\n  }\n}\n\n/**\n * Computes the average value of a sensor over a time range using a 100-point grid.\n * Returns a single-cell scalar value.\n * \n * @customfunction AVERAGE\n * @param sensorName Name of the sensor (e.g., \"Area/Tag\")\n * @param startDatetime Start time (e.g., \"2024-01-01T00:00:00\" or \"8/1/2025 0:00\")\n * @param endDatetime End time (e.g., \"2024-01-31T23:59:59\" or \"8/1/2025 1:40\")\n * @returns Average value as a scalar, or an error string\n */\nexport function AVERAGE(sensorName: string, startDatetime: string, endDatetime: string): any {\n  try {\n    if (!sensorName || typeof sensorName !== 'string' || sensorName.trim() === '') {\n      return \"Error: Sensor name is required\";\n    }\n\n    const startDate = parseDate(startDatetime);\n    const endDate = parseDate(endDatetime);\n\n    if (!startDate || !endDate) {\n      return \"Error: Invalid datetime format. Use formats like: 8/1/2025 0:00 or 2024-01-01T00:00:00\";\n    }\n    if (startDate >= endDate) {\n      return \"Error: Start datetime must be before end datetime\";\n    }\n\n    const authCredentials = getStoredCredentials();\n    if (!authCredentials) {\n      return \"Error: Not authenticated to Seeq. Please use the SqExcel taskpane to authenticate first.\";\n    }\n\n    // Determine grid from 100 points\n    const timeRangeSeconds = Math.floor((endDate.getTime() - startDate.getTime()) / 1000);\n    const points = 100;\n    const secondsPerPoint = Math.floor(timeRangeSeconds / points);\n    if (secondsPerPoint < 1) {\n      return \"Error: Time range too short for 100 points. Use a longer range.\";\n    }\n    const grid = `${secondsPerPoint}s`;\n\n    const userTimezone = (function() {\n      try {\n        const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;\n        return tz || 'UTC';\n      } catch (_e) {\n        return 'UTC';\n      }\n    })();\n\n    const result = callBackendSync('/api/seeq/sensor-data', {\n      sensorNames: [sensorName.trim()],\n      startDatetime,\n      endDatetime,\n      grid,\n      userTimezone,\n      url: authCredentials.url,\n      accessKey: authCredentials.accessKey,\n      password: authCredentials.password,\n      authProvider: \"Seeq\",\n      ignoreSslErrors: false\n    });\n\n    if (result.success && Array.isArray(result.data) && result.data.length > 0) {\n      const columns: string[] = result.data_columns || [];\n      if (!columns || columns.length === 0) {\n        return \"Error: No data columns returned\";\n      }\n      const valueColumn = columns[0];\n      let sum = 0;\n      let count = 0;\n      for (const row of result.data) {\n        const v = row[valueColumn];\n        if (typeof v === 'number') {\n          sum += v;\n          count += 1;\n        } else if (typeof v === 'string') {\n          const parsed = parseFloat(v);\n          if (!isNaN(parsed)) {\n            sum += parsed;\n            count += 1;\n          }\n        }\n      }\n      if (count === 0) {\n        return \"Error: No numeric data to average\";\n      }\n      return sum / count;\n    }\n\n    return \"Error: \" + (result.error || result.message || \"No data returned\");\n  } catch (error) {\n    return \"Error: \" + (error instanceof Error ? error.message : 'Unknown error');\n  }\n}\n\n/**\n * Beautiful color mapping for plots\n */\nconst COLOR_MAP: { [key: string]: string } = {\n  'red': '#FF006E',\n  'blue': '#3A86FF',\n  'green': '#40C9A2',\n  'yellow': '#FFBE0B',\n  'black': '#1C1C1C',\n  'gray': '#6C757D',\n  'grey': '#6C757D',\n  'orange': '#FF6B35',\n  'purple': '#8B5CF6',\n  'pink': '#F472B6',\n  'brown': '#A0522D',\n  'maroon': '#B03A2E',\n  'cyan': '#17A2B8',\n  'slate': '#2F3640'\n};\n\n/**\n * Helper function to get color hex code from color name or return hex if already provided\n */\nfunction getColorHex(colorInput: string): string {\n  // If it's already a hex color, return as-is\n  if (colorInput.startsWith('#')) {\n    return colorInput;\n  }\n  \n  // Look up in color map (case insensitive)\n  const normalizedColor = colorInput.toLowerCase();\n  return COLOR_MAP[normalizedColor] || COLOR_MAP['green']; // Default to green if not found\n}\n\n/**\n * Creates Python plotting code with embedded sensor data for visualization.\n * This function fetches sensor data and returns complete Python code as text.\n * \n * @customfunction CREATE_PLOT_CODE\n * @param sensorNames Range containing sensor names (e.g., B1:D1)\n * @param startDatetime Start time for data pull (ISO format: \"2024-01-01T00:00:00\" or \"8/1/2025 0:00\")\n * @param endDatetime End time for data pull (ISO format: \"2024-01-31T23:59:59\" or \"8/3/2025 0:00\")\n * @param points Number of data points to retrieve (defaults to 100)\n * @param height Plot height in inches (defaults to 0.3)\n * @param aspectRatio Width to height ratio (defaults to 5)\n * @param showLine Whether to show connecting lines (defaults to true)\n * @param showPoints Whether to show data points (defaults to true)\n * @param opacity Point and line opacity 0-1 (defaults to 0.9)\n * @param color Plot color - use color names like 'green', 'blue', 'red' or hex codes (defaults to 'green')\n * @param style Plot style: 'normal', 'minimal', or 'sparkline' (defaults to 'sparkline')\n * @param label Y-axis label (defaults to 'Value')\n * @returns Python code as text string\n */\nexport function CREATE_PLOT_CODE(\n  sensorNames: string[][],\n  startDatetime: string,\n  endDatetime: string,\n  points?: number,\n  height?: number,\n  aspectRatio?: number,\n  showLine?: boolean,\n  showPoints?: boolean,\n  opacity?: number,\n  color?: string,\n  style?: string,\n  label?: string\n): string {\n  try {\n    // Set default values for optional parameters\n    const actualPoints = points || 100;\n    const actualHeight = height || 0.3;\n    const actualAspectRatio = aspectRatio || 5;\n    const actualShowLine = showLine !== undefined ? showLine : true;\n    const actualShowPoints = showPoints !== undefined ? showPoints : true;\n    const actualOpacity = opacity || 0.9;\n    const actualColor = getColorHex(color || 'green');\n    const actualStyle = style || 'sparkline';\n    const actualLabel = label || 'Value';\n    \n    // Flatten the sensor names array and filter out empty cells\n    const sensorNamesList = sensorNames\n      .flat()\n      .filter(name => name && name.trim() !== \"\");\n    \n    if (sensorNamesList.length === 0) {\n      return \"Error: No sensor names provided\";\n    }\n\n    // For now, we'll use the first sensor name for single sensor plotting\n    const sensorName = sensorNamesList[0];\n    \n    // Validate datetime format\n    const startDate = parseDate(startDatetime);\n    const endDate = parseDate(endDatetime);\n    \n    if (!startDate || !endDate) {\n      return \"Error: Invalid datetime format. Use formats like: 8/1/2025 0:00 or 2024-01-01T00:00:00\";\n    }\n    \n    if (startDate >= endDate) {\n      return \"Error: Start datetime must be before end datetime\";\n    }\n\n    // Calculate time range and grid for the specified number of points\n    const timeRangeMs = endDate.getTime() - startDate.getTime();\n    const timeRangeSeconds = Math.floor(timeRangeMs / 1000);\n    const secondsPerPoint = Math.floor(timeRangeSeconds / actualPoints);\n    \n    if (secondsPerPoint < 1) {\n      return \"Error: Time range too short for requested number of points. Try fewer points or a longer time range.\";\n    }\n    \n    const grid = `${secondsPerPoint}s`;\n\n    // Check if we have stored credentials\n    const authCredentials = getStoredCredentials();\n    if (!authCredentials) {\n      return \"Error: Not authenticated to Seeq. Please use the SqExcel taskpane to authenticate first.\";\n    }\n    \n    // Get user's timezone\n    const userTimezone = (function() {\n      try {\n        const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;\n        return tz || 'UTC';\n      } catch (_e) {\n        return 'UTC';\n      }\n    })();\n    \n    // Call backend server to get sensor data\n    const result = callBackendSync('/api/seeq/sensor-data', {\n      sensorNames: [sensorName],\n      startDatetime,\n      endDatetime,\n      grid,\n      userTimezone,\n      url: authCredentials.url,\n      accessKey: authCredentials.accessKey,\n      password: authCredentials.password,\n      authProvider: \"Seeq\",\n      ignoreSslErrors: false\n    });\n    \n    if (!result.success || !result.data || result.data.length === 0) {\n      // Provide more detailed error information for debugging\n      let errorMsg = \"Error: No data returned from sensor. \";\n      if (result.error) {\n        errorMsg += \"Error: \" + result.error;\n      }\n      if (result.message) {\n        errorMsg += \" Message: \" + result.message;\n      }\n      if (result.status_code) {\n        errorMsg += \" Status: \" + result.status_code;\n      }\n      if (result.responseText) {\n        errorMsg += \" Response: \" + result.responseText.substring(0, 200);\n      }\n      return errorMsg;\n    }\n\n    // Extract timestamps and sensor values\n    const timestamps: string[] = [];\n    const sensorValues: (number | string)[] = [];\n    const valueColumn = result.data_columns?.[0];\n    \n    if (!valueColumn) {\n      return \"Error: No data columns returned\";\n    }\n\n    result.data.forEach((row: any) => {\n      const timestamp = row.Timestamp || row.index;\n      const value = row[valueColumn];\n      if (timestamp !== undefined && value !== undefined) {\n        // Convert timestamp to ISO string for Python datetime parsing\n        let timestampStr: string;\n        if (timestamp instanceof Date) {\n          timestampStr = timestamp.toISOString();\n        } else if (typeof timestamp === 'number') {\n          // Handle Excel serial numbers or Unix timestamps\n          const date = new Date(timestamp > 100000 ? timestamp : (timestamp - 25569) * 86400000);\n          timestampStr = date.toISOString();\n        } else {\n          timestampStr = String(timestamp);\n        }\n        timestamps.push(timestampStr);\n        sensorValues.push(value);\n      }\n    });\n\n    if (timestamps.length === 0) {\n      return \"Error: No valid data points found\";\n    }\n\n    // Generate Python code with embedded data\n    const pythonCode = generatePythonPlotCode(\n      timestamps,\n      sensorValues,\n      actualHeight,\n      actualAspectRatio,\n      actualShowLine,\n      actualShowPoints,\n      actualOpacity,\n      actualColor,\n      actualStyle,\n      actualLabel\n    );\n\n    return pythonCode;\n    \n  } catch (error) {\n    return \"Error: \" + (error instanceof Error ? error.message : 'Unknown error');\n  }\n}\n\n/**\n * Helper function to generate Python plotting code with embedded data\n */\nfunction generatePythonPlotCode(\n  timestamps: string[],\n  sensorValues: (number | string)[],\n  height: number,\n  aspectRatio: number,\n  showLine: boolean,\n  showPoints: boolean,\n  opacity: number,\n  color: string,\n  style: string,\n  label: string\n): string {\n  // Convert arrays to Python list format\n  const timestampsPython = timestamps.map(t => `'${t}'`).join(', ');\n  const valuesPython = sensorValues.map(v => \n    typeof v === 'number' ? v.toString() : `'${v}'`\n  ).join(', ');\n\n  return `import pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\nfrom datetime import datetime\n\n# Data from Seeq sensor\ntimestamps = [${timestampsPython}]\nsensor_values = [${valuesPython}]\n\n# Convert timestamps to datetime objects\ntimestamps = [datetime.fromisoformat(ts.replace('Z', '+00:00')) for ts in timestamps]\n\n# Create DataFrame\ndf = pd.DataFrame({'timestamp': timestamps, 'sensor_value': sensor_values})\n\n# Plot parameters\nheight = ${height}\naspect_ratio = ${aspectRatio}\nshow_line = ${showLine ? 'True' : 'False'}\nshow_points = ${showPoints ? 'True' : 'False'}\nopacity = ${opacity}\ncolor = '${color}'\nstyle = '${style}'  # 'normal', 'minimal', or 'sparkline'\nlabel = '${label}'\n\n# Calculate marker size and line width based on figure height\nbase_markersize = 2.2\nbase_linewidth = 2\nmax_marker_size = 4\nopacity_ratio = 0.7  # lower means fainter lines\n\nscaled_markersize = min(base_markersize * height, max_marker_size)\nscaled_linewidth = base_linewidth / base_markersize * scaled_markersize\n\nplt.figure(figsize=(height * aspect_ratio, height), facecolor='#F7F7F7')\nlinestyle = '-' if show_line else 'None'\nmarker = 'o' if show_points else 'None'\nline_alpha = opacity * opacity_ratio if show_points else opacity\nplt.plot(df['timestamp'], df['sensor_value'], linestyle=linestyle, marker=marker, linewidth=scaled_linewidth, markersize=scaled_markersize, color=color, alpha=line_alpha, markerfacecolor=color, markeredgecolor=color, markerfacecoloralt=color)\nif show_points:\n    plt.plot(df['timestamp'], df['sensor_value'], linestyle='None', marker='o', markersize=scaled_markersize, color=color, alpha=opacity)\n\nif style == 'normal':\n    plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%m-%d-%y %H:%M'))\n    plt.xticks(rotation=45, ha='right')\n    plt.ylabel(label)\n    plt.tight_layout()\nelif style == 'minimal':\n    # Only show first and last timestamp\n    ax = plt.gca()\n    ax.set_xticks([df['timestamp'].iloc[0], df['timestamp'].iloc[-1]])\n    ax.xaxis.set_major_formatter(mdates.DateFormatter('%m-%d-%y %H:%M'))\n    plt.xticks(rotation=0, ha='center')  # Flat text direction\n    plt.ylabel(label)\n    # Remove grid lines\n    ax.grid(False)\n    # Maximize figure area - remove margins\n    plt.subplots_adjust(left=0.1, right=1.0, top=1.0, bottom=0.15)\nelif style == 'sparkline':\n    # Create a new figure without frame for sparkline\n    plt.clf()  # Clear the figure\n    plt.gcf().patch.set_visible(False)  # Remove figure background/frame\n    ax = plt.axes([0, 0, 1, 1])  # Create axes that fill entire figure\n    \n    # Plot the data again since we cleared the figure\n    plt.plot(df['timestamp'], df['sensor_value'], linestyle=linestyle, marker=marker, \n             linewidth=scaled_linewidth, markersize=scaled_markersize, color=color, \n             alpha=line_alpha, markerfacecolor=color, markeredgecolor=color)\n    if show_points:\n        plt.plot(df['timestamp'], df['sensor_value'], linestyle='None', marker='o', \n                 markersize=scaled_markersize, color=color, alpha=opacity)\n    \n    # Remove all spines\n    for k, v in ax.spines.items():\n        v.set_visible(False)\n    ax.set_xticks([])\n    ax.set_yticks([])\n    \n    # Remove grid and set margins to zero\n    ax.grid(False)\n    ax.margins(0)\n    \n    # Get min/max values for annotations\n    y_min = df['sensor_value'].min()\n    y_max = df['sensor_value'].max()\n    \n    # Add min/max as text annotations positioned within plot area\n    ax.text(1, 0.99, f'{y_max:.1f}', transform=ax.transAxes, fontsize=8, \n            verticalalignment='top', horizontalalignment='left', color='black')\n    ax.text(1, 0.01, f'{y_min:.1f}', transform=ax.transAxes, fontsize=8, \n            verticalalignment='bottom', horizontalalignment='left', color='black')\n\nplt.show()`;\n}\n\n\nCustomFunctions.associate(\"PULL\", PULL);\nCustomFunctions.associate(\"SEARCH_SENSORS\", SEARCH_SENSORS);\nCustomFunctions.associate(\"CURRENT\", CURRENT);\nCustomFunctions.associate(\"AVERAGE\", AVERAGE);\nCustomFunctions.associate(\"CREATE_PLOT_CODE\", CREATE_PLOT_CODE);"],"names":["__webpack_require__","d","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","BACKEND_URL","getStoredCredentials","saved","localStorage","getItem","credentials","JSON","parse","savedTime","Date","timestamp","getTime","removeItem","error","callBackendSync","endpoint","data","arguments","length","undefined","xhr","XMLHttpRequest","url","concat","open","setRequestHeader","send","stringify","status","success","statusText","responseText","e","message","rawResponse","Error","details","stack","parseDate","dateString","trimmed","trim","test","serialNumber","parseFloat","isNaN","daysSinceUnixEpoch","msUtc","Math","round","tzAtDateMin","getTimezoneOffset","includes","ymdLocal","match","_ymdLocal","_slicedToArray","y","m","hh","mm","ss","parseInt","date","COLOR_MAP","CustomFunctions","associate","sensorNames","startDatetime","endDatetime","mode","modeValue","startDate","endDate","sensorNamesList","flat","filter","name","timeRangeMs","timeRangeSeconds","floor","grid","actualMode","actualModeValue","String","numPoints","secondsPerPoint","authCredentials","result","userTimezone","Intl","DateTimeFormat","resolvedOptions","timeZone","_e","accessKey","password","authProvider","ignoreSslErrors","headers","data_columns","dataRows","map","row","excelSerialTimestamp","asNum","localMatch","_localMatch","parsed","nd","tzOffsetMin","_err","convertToExcelSerialNumber","Timestamp","index","values","col","join","searchCredentials","search_results","sensor","sensorName","now","toISOString","Array","isArray","columns","valueColumn","value","_step","sum","count","_iterator","_createForOfIteratorHelper","s","n","done","v","err","f","points","height","aspectRatio","showLine","showPoints","opacity","color","style","label","_result$data_columns","actualPoints","actualHeight","actualAspectRatio","actualShowLine","actualShowPoints","actualOpacity","actualColor","colorInput","startsWith","normalizedColor","toLowerCase","getColorHex","actualStyle","actualLabel","errorMsg","status_code","substring","timestamps","sensorValues","forEach","timestampStr","push","pythonCode","timestampsPython","t","valuesPython","toString","generatePythonPlotCode"],"sourceRoot":""}