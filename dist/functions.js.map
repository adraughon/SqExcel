{"version":3,"file":"functions.js","mappings":"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","sources":["webpack://excel-custom-functions/webpack/bootstrap","webpack://excel-custom-functions/webpack/runtime/define property getters","webpack://excel-custom-functions/webpack/runtime/hasOwnProperty shorthand","webpack://excel-custom-functions/./src/functions/functions.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","/*\n * Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n * See LICENSE in the project root for license information.\n */\n\n/* global clearInterval, console, CustomFunctions, setInterval, XMLHttpRequest */\n\n/**\n * SqExcel Custom Functions\n * \n * This add-in provides 2 Excel functions for working with Seeq data:\n * - SEARCH_SENSORS: Search for sensors in your Seeq environment\n * - PULL: Pull time series data from Seeq sensors\n * \n * SETUP INSTRUCTIONS:\n * 1. Create a Seeq Access Key:\n *    - Go to your Seeq environment\n *    - Click on your username in the top right\n *    - Select \"Create Access Key\"\n *    - Copy both the Key (ID) and Password - you'll need both!\n * \n * 2. Authenticate in Excel:\n *    - Open the SqExcel taskpane (if not visible, go to Insert > My Add-ins)\n *    - Enter your Seeq server URL (e.g., https://your-server.seeq.tech)\n *    - Enter the Access Key and Password from step 1\n *    - Click \"Authenticate\"\n *    - Once authenticated, you can use the Excel functions below\n * \n * 3. Using the Functions:\n *    - SEARCH_SENSORS: =SEARCH_SENSORS(A1:C1) where A1:C1 contains sensor names\n *    - PULL: =PULL(A1:C1,\"2024-01-01T00:00:00\",\"2024-01-31T23:59:59) - defaults to 1000 points\n *    - PULL with grid: =PULL(A1:C1,\"2024-01-01T00:00:00\",\"2024-01-31T23:59:59\",\"grid\",\"15min\")\n *    - PULL with points: =PULL(A1:C1,\"2024-01-01T00:00:00\",\"2024-01-31T23:59:59,\"points\",500)\n * \n * TROUBLESHOOTING:\n * - If you see \"#NAME?\" errors, make sure the add-in is properly loaded\n * - If authentication fails, check your Seeq server URL and credentials\n * - If data doesn't load, verify your sensor names exist in Seeq\n * - For detailed diagnostics, run a connection test in the taskpane\n */\n\n\n// Backend server configuration\nconst BACKEND_URL = 'https://sqexcel.up.railway.app';\n\n/**\n * Helper function to get stored Seeq credentials from localStorage\n */\nfunction getStoredCredentials(): any {\n  try {\n    // Get credentials from localStorage (same storage used by taskpane)\n    const saved = localStorage.getItem(\"seeq_credentials\");\n    if (saved) {\n      const credentials = JSON.parse(saved);\n      \n      // Check if credentials are still valid (not expired)\n      const savedTime = new Date(credentials.timestamp);\n      const now = new Date();\n      const hoursDiff = (now.getTime() - savedTime.getTime()) / (1000 * 60 * 60);\n      \n      if (hoursDiff < 24) { // Credentials valid for 24 hours\n        return credentials;\n      } else {\n        // Credentials expired, remove them\n        localStorage.removeItem(\"seeq_credentials\");\n      }\n    }\n    return null;\n  } catch (error) {\n    return null;\n  }\n}\n\n/**\n * Helper function to make synchronous HTTP requests to the backend server\n * Note: This uses XMLHttpRequest synchronously, which is deprecated but works in Excel custom functions\n */\nfunction callBackendSync(endpoint: string, data: any = null): any {\n  try {\n    const xhr = new XMLHttpRequest();\n    const url = `${BACKEND_URL}${endpoint}`;\n    \n    \n    // Use synchronous request (deprecated but works in Excel custom functions)\n    xhr.open(data ? 'POST' : 'GET', url, false);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    \n    \n    if (data) {\n      xhr.send(JSON.stringify(data));\n    } else {\n      xhr.send();\n    }\n    \n    \n    if (xhr.status === 200) {\n      try {\n        const parsed = JSON.parse(xhr.responseText);\n        return parsed;\n      } catch (e) {\n        return {\n          success: false,\n          error: `Failed to parse response: ${(e as Error).message}`,\n          rawResponse: xhr.responseText\n        };\n      }\n    } else {\n      return {\n        success: false,\n        error: `HTTP ${xhr.status}: ${xhr.statusText}`,\n        responseText: xhr.responseText,\n        url: url\n      };\n    }\n  } catch (error) {\n    return {\n      success: false,\n      error: `Backend request failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n      details: error instanceof Error ? error.stack : 'No stack trace',\n      url: `${BACKEND_URL}${endpoint}`\n    };\n  }\n}\n\n\n/**\n * Helper function to convert timestamps to Excel serial numbers\n * Returns Excel's internal date representation for better compatibility\n * Excel serial number = (JS timestamp / (1000 * 60 * 60 * 24)) + 25569\n * \n * Note: These serial numbers will display as large numbers (e.g., 45870.0)\n * To see them as readable dates, users should:\n * 1. Select the timestamp column\n * 2. Right-click → Format Cells → Date\n * 3. Choose desired date format (e.g., \"3/14/12 1:30 PM\")\n * \n * This function preserves the original timezone information from the backend\n * to ensure timestamps display correctly in the user's local timezone.\n */\nfunction convertToExcelSerialNumber(timestamp: any): number {\n  try {\n    // Handle different timestamp formats that might come from the backend\n    let date: Date;\n    \n    if (typeof timestamp === 'string') {\n      // Parse naive local time strings manually to avoid timezone conversion\n      // Format: \"YYYY-MM-DD HH:MM:SS\"\n      const match = timestamp.match(/^(\\d{4})-(\\d{2})-(\\d{2})\\s+(\\d{2}):(\\d{2}):(\\d{2})$/);\n      if (match) {\n        const [, year, month, day, hour, minute, second] = match;\n        // Create date in local timezone without timezone conversion\n        date = new Date(parseInt(year), parseInt(month) - 1, parseInt(day), parseInt(hour), parseInt(minute), parseInt(second));\n      } else {\n        // Fallback to standard parsing\n        date = new Date(timestamp);\n      }\n    } else if (timestamp instanceof Date) {\n      date = timestamp;\n    } else if (typeof timestamp === 'number') {\n      // Handle Unix timestamp\n      date = new Date(timestamp);\n    } else {\n      // Fallback for unknown formats\n      return 0; // Return 0 for invalid dates\n    }\n    \n    // Check if date is valid\n    if (isNaN(date.getTime())) {\n      return 0; // Return 0 for invalid dates\n    }\n    \n    // Convert to Excel serial number\n    // Goal: preserve LOCAL wall-clock time when shown in Excel (Excel is timezone-agnostic)\n    // Strategy: subtract the local timezone offset so that local midnight stays midnight in serial fraction\n    const tzOffsetMs = date.getTimezoneOffset() * 60 * 1000; // minutes -> ms\n    const localWallClockMs = date.getTime() - tzOffsetMs;\n    const excelSerial = localWallClockMs / (1000 * 60 * 60 * 24) + 25569; // 25569 = days from 1899-12-30 to 1970-01-01\n    \n    // For debug calls, we'll return the serial number but log the debug info\n    if (typeof timestamp === 'string' && timestamp.includes('DEBUG')) {\n      // We can't return a string from a number function, so just return the serial\n      // The debug info will be visible in the data itself\n      return excelSerial;\n    }\n    \n    return excelSerial;\n  } catch (error) {\n    // If any error occurs during conversion, return 0\n    return 0;\n  }\n}\n\n/**\n * Custom date parsing function to handle various date formats consistently\n * @param dateString - Date string in various formats\n * @returns Date object or null if parsing fails\n */\nfunction parseDate(dateString: string): Date | null {\n  if (!dateString || typeof dateString !== 'string') {\n    return null;\n  }\n\n  // Handle Excel serial numbers (e.g., \"45870\", \"45874\")\n  const serialNumber = parseFloat(dateString);\n  if (!isNaN(serialNumber) && serialNumber > 0 && serialNumber < 100000) {\n    // Excel serial number: days since 1900-01-01 (with 1900 leap year bug)\n    // Convert to JavaScript Date\n    const excelEpoch = new Date(1900, 0, 1); // January 1, 1900\n    const jsDate = new Date(excelEpoch.getTime() + (serialNumber - 2) * 24 * 60 * 60 * 1000);\n    return jsDate;\n  }\n\n  // Handle ISO format (YYYY-MM-DDTHH:MM:SS)\n  if (dateString.includes('T')) {\n    return new Date(dateString);\n  }\n\n  // Handle M/D/YYYY H:MM format (e.g., \"8/1/2025 0:00\")\n  const mdyMatch = dateString.match(/^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})\\s+(\\d{1,2}):(\\d{2})$/);\n  if (mdyMatch) {\n    const [, month, day, year, hour, minute] = mdyMatch;\n    return new Date(parseInt(year), parseInt(month) - 1, parseInt(day), parseInt(hour), parseInt(minute));\n  }\n\n  // Handle M/D/YYYY format (e.g., \"8/1/2025\")\n  const mdyDateMatch = dateString.match(/^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/);\n  if (mdyDateMatch) {\n    const [, month, day, year] = mdyDateMatch;\n    return new Date(parseInt(year), parseInt(month) - 1, parseInt(day));\n  }\n\n  // Fallback to native Date parsing\n  const date = new Date(dateString);\n  return isNaN(date.getTime()) ? null : date;\n}\n\n/**\n * Pulls time series data from Seeq sensors over a specified time range.\n * This is an array function that should be called on a range that can accommodate the output.\n * \n * @customfunction PULL\n * @param sensorNames Range containing sensor names (e.g., B1:D1)\n * @param startDatetime Start time for data pull (ISO format: \"2024-01-01T00:00:00\" or \"8/1/2025 0:00\")\n * @param endDatetime End time for data pull (ISO format: \"2024-01-31T23:59:59\" or \"8/3/2025 0:00\")\n * @param mode Data retrieval mode: \"grid\" for time-based intervals or \"points\" for number of points - defaults to \"points\"\n * @param modeValue Grid interval (e.g., \"15min\", \"1h\", \"1d\") when mode=\"grid\" OR number of points when mode=\"points\" - defaults to 1000\n * @returns Array containing timestamp column (as Excel serial numbers) and sensor data columns\n * \n * TIMEZONE BEHAVIOR:\n * - Input dates without timezone info are treated as local timezone\n * - Returned data timestamps are in the same timezone as the input (local timezone)\n * - This matches user expectations for natural date/time input\n */\nexport function PULL(\n  sensorNames: string[][],\n  startDatetime: string,\n  endDatetime: string,\n  mode: string = \"points\",\n  modeValue: string | number = 1000\n): string[][] {\n  try {\n    // Flatten the sensor names array and filter out empty cells\n    const sensorNamesList = sensorNames\n      .flat()\n      .filter(name => name && name.trim() !== \"\");\n    \n    if (sensorNamesList.length === 0) {\n      return [[\"Error: No sensor names provided\"]];\n    }\n    \n    // Validate datetime format and ensure consistent timezone handling\n    let startDate: Date;\n    let endDate: Date;\n    \n  // Parse dates using custom parser\n  startDate = parseDate(startDatetime);\n  endDate = parseDate(endDatetime);\n  \n  if (!startDate || !endDate) {\n    return [[\"Error: Invalid datetime format. Use formats like: 8/1/2025 0:00 or 2024-01-01T00:00:00\"]];\n  }\n  \n  // Calculate time range in seconds (needed for both modes)\n  const timeRangeMs = endDate.getTime() - startDate.getTime();\n  const timeRangeSeconds = Math.floor(timeRangeMs / 1000);\n    \n    if (startDate >= endDate) {\n      return [[\"Error: Start datetime must be before end datetime\"]];\n    }\n    \n    // Validate mode parameter\n    if (mode !== \"grid\" && mode !== \"points\") {\n      return [[\"Error: Mode must be 'grid' or 'points'\"]];\n    }\n    \n    \n    // Calculate grid based on mode\n    let grid: string;\n    if (mode === \"grid\") {\n      // Use modeValue as grid directly\n      grid = String(modeValue);\n      // Validate grid format\n      const gridPattern = /^(\\d+)(min|h|d|s)$/;\n      if (!gridPattern.test(grid)) {\n        return [[\"Error: Invalid grid format. Use format like '15min', '1h', '1d', '30s'\"]];\n      }\n    } else {\n      // mode === \"points\" - calculate grid from number of points\n      const numPoints = typeof modeValue === 'number' ? modeValue : parseInt(String(modeValue));\n      if (isNaN(numPoints) || numPoints <= 0) {\n        return [[\"Error: Number of points must be a positive integer\"]];\n      }\n      \n      // Calculate seconds per point (must be integer)\n      const secondsPerPoint = Math.floor(timeRangeSeconds / numPoints);\n      \n      if (secondsPerPoint < 1) {\n        return [\n          [\"Error: Time range too short for requested number of points. Try fewer points or a longer time range.\"]\n        ];\n      }\n      \n      // Convert to grid format\n      grid = `${secondsPerPoint}s`;\n    }\n\n        // Check if we have stored credentials\n    const authCredentials = getStoredCredentials();\n    if (!authCredentials) {\n      return [[\"Error: Not authenticated to Seeq. Please use the SqExcel taskpane to authenticate first.\"]];\n    }\n    \n    // Get user's timezone\n    const userTimezone = (function() {\n      try {\n        const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;\n        return tz || 'UTC';\n      } catch (_e) {\n        return 'UTC';\n      }\n    })();\n    \n    // Call backend server with credentials\n    const result = callBackendSync('/api/seeq/sensor-data', {\n      sensorNames: sensorNamesList,\n      startDatetime,\n      endDatetime,\n      grid,\n      userTimezone,\n      url: authCredentials.url,\n      accessKey: authCredentials.accessKey,\n      password: authCredentials.password,\n      authProvider: \"Seeq\",\n      ignoreSslErrors: false\n    });\n    \n    if (result.success && result.data && result.data.length > 0) {\n      // Create header row with timestamp and sensor names\n      const headers = [\"Timestamp\"].concat(result.data_columns || []);\n      \n      // Create data rows with formatted timestamps\n      const dataRows = result.data.map((row: any) => {\n        const timestamp = row.Timestamp || row.index || \"N/A\";\n        // Convert timestamp to Excel serial number for best compatibility\n        const excelSerialTimestamp = convertToExcelSerialNumber(timestamp);\n        const values = (result.data_columns || []).map((col: string) => {\n          return row[col] !== undefined ? row[col] : \"N/A\";\n        });\n        return [excelSerialTimestamp].concat(values);\n      });\n      \n      \n      return [headers].concat(dataRows);\n    } else {\n      // Check if backend server is not running\n      if (result.error && result.error.includes('Failed to fetch') || result.error.includes('NetworkError')) {\n        return [\n          [\"Backend server not running\"],\n          [\"Please start the backend server:\"],\n          [\"1. Open terminal in the backend folder\"],\n          [\"2. Run: npm install && npm start\"],\n          [\"3. Then use this function again\"]\n        ];\n      }\n      \n      return [\n        [\"No data returned\"],\n        [\"Error: \" + (result.error || result.message || \"Unknown error\")],\n        [\"Sensors: \" + sensorNamesList.join(\", \")],\n        [\"Time Range: \" + startDatetime + \" to \" + endDatetime]\n      ];\n    }\n    \n  } catch (error) {\n    return [[\"Error: \" + (error instanceof Error ? error.message : 'Unknown error')]];\n  }\n}\n\n/**\n * Searches for sensors in Seeq without pulling data.\n * \n * @customfunction SEARCH_SENSORS\n * @param sensorNames Range containing sensor names (e.g., B1:D1)\n * @returns Array containing search results for each sensor\n */\nexport function SEARCH_SENSORS(sensorNames: string[][]): string[][] {\n  try {\n    // Flatten the sensor names array and filter out empty cells\n    const sensorNamesList = sensorNames\n      .flat()\n      .filter(name => name && name.trim() !== \"\");\n    \n    if (sensorNamesList.length === 0) {\n      return [[\"Error: No sensor names provided\"]];\n    }\n\n    // Check if we have stored credentials\n    const searchCredentials = getStoredCredentials();\n    if (!searchCredentials) {\n      return [[\"Error: Not authenticated to Seeq. Please use the SqExcel taskpane to authenticate first.\"]];\n    }\n    \n    // Call backend server with credentials\n    const result = callBackendSync('/api/seeq/search-sensors', {\n      sensorNames: sensorNamesList,\n      url: searchCredentials.url,\n      accessKey: searchCredentials.accessKey,\n      password: searchCredentials.password,\n      authProvider: \"Seeq\",\n      ignoreSslErrors: false\n    });\n    \n    if (result.success && result.search_results && result.search_results.length > 0) {\n      // Create header row\n      const headers = [\"Name\", \"ID\", \"Datasource Name\", \"Value Unit Of Measure\", \"Description\"];\n      \n      // Create data rows\n      const dataRows = result.search_results.map((sensor: any) => {\n        return [\n          sensor[\"Name\"] || \"N/A\",\n          sensor[\"ID\"] || \"Not Found\",\n          sensor[\"Datasource Name\"] || \"N/A\",\n          sensor[\"Value Unit Of Measure\"] || \"N/A\",\n          sensor[\"Description\"] || \"N/A\"\n        ];\n      });\n      \n      return [headers].concat(dataRows);\n    } else {\n      // Check if backend server is not running\n      if (result.error && result.error.includes('Failed to fetch') || result.error.includes('NetworkError')) {\n        return [\n          [\"Backend server not running\"]\n        ];\n      }\n      \n      return [\n        [\"No search results returned\"],\n        [\"Error: \" + (result.error || result.message || \"Unknown error\")],\n        [\"Sensors: \" + sensorNamesList.join(\", \")]\n      ];\n    }\n    \n  } catch (error) {\n    return [[\"Error: \" + (error instanceof Error ? error.message : 'Unknown error')]];\n  }\n}\n\n/**\n * Timestamp diagnostics helper exposed to Excel for debugging timezone issues.\n * Place =DEBUG(A1) or =DEBUG(\"8/1/2025 00:00\") in a cell to see details.\n *\n * @customfunction DEBUG\n * @param input Timestamp string or serial to diagnose\n * @returns 2D table of key/value diagnostics\n */\nexport function DEBUG(input: string): string[][] {\n  try {\n    const rows: string[][] = [];\n    const now = new Date();\n    const tzOffsetMin = now.getTimezoneOffset();\n    const tzName = (() => {\n      try { return Intl.DateTimeFormat().resolvedOptions().timeZone || 'Unknown'; } catch (_e) { return 'Unknown'; }\n    })();\n\n    rows.push([\"Input\", String(input)]);\n    rows.push([\"Timezone name\", tzName]);\n    rows.push([\"Timezone offset (min)\", String(tzOffsetMin)]);\n\n    // Parse using native Date first\n    const nativeDate = new Date(input as any);\n    rows.push([\"Native parse valid\", String(!isNaN(nativeDate.getTime()))]);\n    rows.push([\"Native local\", isNaN(nativeDate.getTime()) ? \"Invalid\" : nativeDate.toString()]);\n    rows.push([\"Native UTC ISO\", isNaN(nativeDate.getTime()) ? \"Invalid\" : nativeDate.toISOString()]);\n    rows.push([\"Native getTime()\", isNaN(nativeDate.getTime()) ? \"Invalid\" : String(nativeDate.getTime())]);\n\n    // Parse using custom parser\n    const customDate = parseDate(String(input));\n    rows.push([\"Custom parse valid\", String(!!customDate && !isNaN(customDate.getTime()))]);\n    rows.push([\"Custom local\", !customDate ? \"Invalid\" : customDate.toString()]);\n    rows.push([\"Custom UTC ISO\", !customDate ? \"Invalid\" : customDate.toISOString()]);\n    rows.push([\"Custom getTime()\", !customDate ? \"Invalid\" : String(customDate.getTime())]);\n\n    // Excel serial using our converter\n    const serialFromInput = convertToExcelSerialNumber(input);\n    rows.push([\"Serial (convertToExcelSerialNumber(input))\", String(serialFromInput)]);\n\n    if (customDate && !isNaN(customDate.getTime())) {\n      const serialFromCustom = convertToExcelSerialNumber(customDate);\n      rows.push([\"Serial (convertToExcelSerialNumber(customDate))\", String(serialFromCustom)]);\n\n      // Show effect of subtracting vs adding the timezone offset (in ms)\n      const offsetMs = tzOffsetMin * 60 * 1000;\n      const minusOffset = new Date(customDate.getTime() - offsetMs);\n      const plusOffset = new Date(customDate.getTime() + offsetMs);\n      rows.push([\"Custom minus offset local\", minusOffset.toString()]);\n      rows.push([\"Custom minus offset UTC ISO\", minusOffset.toISOString()]);\n      rows.push([\"Custom plus offset local\", plusOffset.toString()]);\n      rows.push([\"Custom plus offset UTC ISO\", plusOffset.toISOString()]);\n      rows.push([\"Serial (custom minus offset)\", String(convertToExcelSerialNumber(minusOffset))]);\n      rows.push([\"Serial (custom plus offset)\", String(convertToExcelSerialNumber(plusOffset))]);\n    }\n\n    return [[\"Key\", \"Value\"], ...rows];\n  } catch (e) {\n    return [[\"Error\", e instanceof Error ? e.message : \"Unknown error\"]];\n  }\n}\n\nCustomFunctions.associate(\"PULL\", PULL);\nCustomFunctions.associate(\"SEARCH_SENSORS\", SEARCH_SENSORS);\nCustomFunctions.associate(\"DEBUG\", DEBUG);"],"names":["__webpack_require__","d","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","BACKEND_URL","getStoredCredentials","saved","localStorage","getItem","credentials","JSON","parse","savedTime","Date","timestamp","getTime","removeItem","error","callBackendSync","endpoint","data","arguments","length","undefined","xhr","XMLHttpRequest","url","concat","open","setRequestHeader","send","stringify","status","success","statusText","responseText","e","message","rawResponse","Error","details","stack","convertToExcelSerialNumber","date","match","_match","_slicedToArray","year","month","day","hour","minute","second","parseInt","isNaN","tzOffsetMs","getTimezoneOffset","excelSerial","includes","parseDate","dateString","serialNumber","parseFloat","excelEpoch","mdyMatch","_mdyMatch","mdyDateMatch","_mdyDateMatch","CustomFunctions","associate","sensorNames","startDatetime","endDatetime","mode","modeValue","startDate","endDate","sensorNamesList","flat","filter","name","trim","grid","timeRangeMs","timeRangeSeconds","Math","floor","String","test","numPoints","secondsPerPoint","authCredentials","result","userTimezone","Intl","DateTimeFormat","resolvedOptions","timeZone","_e","accessKey","password","authProvider","ignoreSslErrors","headers","data_columns","dataRows","map","row","excelSerialTimestamp","Timestamp","index","values","col","join","searchCredentials","search_results","sensor","input","rows","tzOffsetMin","tzName","push","nativeDate","toString","toISOString","customDate","serialFromInput","serialFromCustom","offsetMs","minusOffset","plusOffset"],"sourceRoot":""}